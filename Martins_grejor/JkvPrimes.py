import random
from tqdm import tqdm
import concurrent.futures
from functools import partial


def miller_rabin(n, k):
    # Implementation uses the Miller-Rabin Primality Test
    # The optimal number of rounds for this test is 40
    # See http://stackoverflow.com/questions/6325576/how-many-iterations-of-rabin-miller-should-i-use-for-cryptographic-safe-primes
    # for justification
    # If number is even, it's a composite number
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    r, s = 0, n - 1
    while s % 2 == 0:
        r += 1
        s //= 2
    for _ in range(k):
        a = random.randrange(2, n - 1)
        x = pow(a, s, n)

        if x == 1 or x == n - 1:
            continue

        for _ in range(r - 1):
            x = pow(x, 2)
            x %= n
            if x == n - 1:
                break
        else:
            return False
    return True


orign = """
1111111111188888111111111111111111111111111111111
1111111111188888888811111111111111111111111111111
1111111111188888888888881111111111111111111111111
1111111111188888888811111111111111111111111111111
1111111111188888111111111111111111111111111111111
1111111111181111111111111111111111111111111111111
1111111111188111111111111111111111111111111111111
1111111111188811111111111111111111111111111111111
1111111111188881111111111111111111111111111111111
1111111111188888811111111111111111111111111111111
1111111111188888881111111111111111111111111111111
1111111111188888888111111111111111111111111111111
1111111111188888888881111111111111111111111111111
1111111111188888888888111111111111111111111111111
1111111111188888888888881111111111111111111111111
1111111111188888888888888111111111111111111111111
1111111111188888888888888811111111111111111111111
1111111111188888888888888881111111111111111111111
1111111111188888888888888888811111111111111111111
1111111111188888888888888888881111111111111111111
1111111111188888888888888888888111111111111111111
1111111111188888888888888888888811111111111111111
1111111111188888888888888888888888111111111111111
1111111111188888888888888888888888811111111111111
1111111111188888888888888888888888881111111111111
1111111111188888888888888888888888888811111111111
1111111111188888888888888888888888888881111111111
1111111111188888888888888888888888888888111111111
1111111111188888888888888888888888888888881111111
1111111111188888888888888888888888888888888111111
1111111111188888888888888888888888888888888811111
1111111111188888888888888888888888888888888888111
1111111111188888888888888888888888888888888888811
1111111111188888888888888888888888888888888888881
1111111111111111111111111111111111111111111111111
1888888888111111111111111111111111111111111111111
1118888888111111111111111111111111111111111111111
1111188888111111111111111111111111111111111111111
1111111888111111111111111111111111111111111111111
1111111118111111111111111111111111111111111111111
0000000000001
"""
orign = orign[1:]
number = int(orign.replace("\n", ""))

zeropadding = 2000


def make_number(n):
    nl = 5 - len(str(n))
    npadded = "0" * nl + str(n)
    ncopy = list(orign)
    for i, x in enumerate(npadded):
        ncopy[zeropadding + i] = x
    return "".join(ncopy)


def check_numbers(n_list, k=1):

    with concurrent.futures.ThreadPoolExecutor(8) as executor:
        with tqdm(total=len(n_list)) as progress:
            func = partial(miller_rabin, k=k)
            futures = []
            for n_candidate in n_list:
                future = executor.submit(
                    func, int(n_candidate.replace("\n", "")))
                future.add_done_callback(lambda p: progress.update())
                futures.append(future)

            results = []
            for future in futures:
                result = future.result()
                results.append(result)

            return [results[i] for i, x in enumerate(results) if x]


g = check_numbers([make_number(x) for x in range(1000)])
len(g)
